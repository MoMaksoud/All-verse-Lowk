-- Extensions (safe defaults)
CREATE EXTENSION IF NOT EXISTS pgcrypto;      -- gen_random_uuid()
CREATE EXTENSION IF NOT EXISTS citext;        -- case-insensitive email
CREATE EXTENSION IF NOT EXISTS pg_trgm;       -- fuzzy search (optional)

-- ========== USERS ==========
CREATE TABLE app_user (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email           CITEXT UNIQUE NOT NULL CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$'),
  display_name    TEXT NOT NULL CHECK (LENGTH(display_name) BETWEEN 1 AND 100),
  phone_e164      TEXT CHECK (phone_e164 IS NULL OR phone_e164 ~ '^\+[1-9]\d{1,14}$'),
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  last_seen_at    TIMESTAMPTZ,
  deleted_at      TIMESTAMPTZ
);

-- Credentials (if you manage auth yourself; otherwise integrate your provider)
CREATE TABLE auth_local (
  user_id           UUID PRIMARY KEY REFERENCES app_user(id) ON DELETE CASCADE,
  password_hash     TEXT NOT NULL CHECK (LENGTH(password_hash) >= 60), -- bcrypt hash length
  password_updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  password_history  TEXT[] DEFAULT '{}' -- Store last 5 password hashes to prevent reuse
);

-- ========== GEO / LOCATIONS ==========
-- Simple city/region; upgrade to PostGIS later if needed
CREATE TABLE location_area (
  id           UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  country_code CHAR(2) NOT NULL,
  admin1       TEXT,           -- state/province
  city         TEXT,
  postal_code  TEXT
);
CREATE INDEX ON location_area (country_code, admin1, city);

-- ========== TAXONOMY (CATEGORIES & ATTRIBUTES) ==========
CREATE TABLE category (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  parent_id   UUID REFERENCES category(id) ON DELETE SET NULL,
  name        TEXT NOT NULL,
  slug        TEXT UNIQUE
);
CREATE INDEX ON category (parent_id);

-- For category-specific attributes (e.g., "mileage", "size"). JSONB keeps it flexible.
-- You can also create per-category tables later for hot categories.
CREATE TABLE category_attribute (
  id           UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  category_id  UUID NOT NULL REFERENCES category(id) ON DELETE CASCADE,
  key          TEXT NOT NULL,
  datatype     TEXT NOT NULL CHECK (datatype IN ('text','number','boolean','enum','date')),
  enum_values  TEXT[]  -- if datatype='enum'
);
CREATE UNIQUE INDEX ON category_attribute (category_id, key);

-- ========== LISTINGS ==========
CREATE TYPE listing_status AS ENUM ('draft','active','reserved','sold','archived');
CREATE TYPE price_type AS ENUM ('fixed','negotiable','free');

CREATE TABLE listing (
  id             UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  seller_id      UUID NOT NULL REFERENCES app_user(id) ON DELETE CASCADE,
  category_id    UUID NOT NULL REFERENCES category(id),
  title          TEXT NOT NULL CHECK (LENGTH(title) BETWEEN 1 AND 200),
  description    TEXT NOT NULL CHECK (LENGTH(description) BETWEEN 1 AND 5000),
  price_cents    INTEGER NOT NULL CHECK (price_cents >= 0),
  currency       CHAR(3) NOT NULL DEFAULT 'USD' CHECK (currency IN ('USD', 'EUR', 'GBP', 'CAD', 'AUD', 'JPY', 'CHF', 'SEK', 'NOK', 'DKK')),
  price_mode     price_type NOT NULL DEFAULT 'fixed',
  condition_note TEXT CHECK (condition_note IS NULL OR LENGTH(condition_note) <= 500),
  qty_available  INTEGER NOT NULL DEFAULT 1 CHECK (qty_available >= 0),
  location_id    UUID REFERENCES location_area(id),
  allow_shipping BOOLEAN NOT NULL DEFAULT FALSE,
  allow_pickup   BOOLEAN NOT NULL DEFAULT TRUE,
  status         listing_status NOT NULL DEFAULT 'active',
  views          INTEGER NOT NULL DEFAULT 0,
  created_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at     TIMESTAMPTZ NOT NULL DEFAULT now(),
  deleted_at     TIMESTAMPTZ,
  version        INTEGER NOT NULL DEFAULT 1 -- Optimistic locking
);
CREATE INDEX idx_listing_active ON listing (status) WHERE status='active';
CREATE INDEX idx_listing_category ON listing (category_id);
CREATE INDEX idx_listing_price ON listing (currency, price_cents);
CREATE INDEX idx_listing_seller ON listing (seller_id);
CREATE INDEX idx_listing_created_at ON listing (created_at DESC);
CREATE INDEX idx_listing_deleted_at ON listing (deleted_at) WHERE deleted_at IS NULL;
-- basic search helpers
CREATE INDEX idx_listing_title_trgm ON listing USING gin (title gin_trgm_ops);
CREATE INDEX idx_listing_desc_trgm  ON listing USING gin (description gin_trgm_ops);

-- Category-specific attribute values per listing
CREATE TABLE listing_attribute_value (
  listing_id   UUID NOT NULL REFERENCES listing(id) ON DELETE CASCADE,
  attribute_id UUID NOT NULL REFERENCES category_attribute(id) ON DELETE CASCADE,
  value_text   TEXT,
  value_number DOUBLE PRECISION,
  value_bool   BOOLEAN,
  value_date   DATE,
  PRIMARY KEY (listing_id, attribute_id)
);

-- ========== MEDIA ==========
CREATE TABLE listing_image (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  listing_id  UUID NOT NULL REFERENCES listing(id) ON DELETE CASCADE,
  url         TEXT NOT NULL,    -- store S3/Cloud URL
  sort_order  INT NOT NULL DEFAULT 0
);
CREATE INDEX ON listing_image (listing_id, sort_order);

-- ========== FAVORITES / SAVES ==========
CREATE TABLE listing_favorite (
  user_id    UUID NOT NULL REFERENCES app_user(id) ON DELETE CASCADE,
  listing_id UUID NOT NULL REFERENCES listing(id) ON DELETE CASCADE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  PRIMARY KEY (user_id, listing_id)
);

-- ========== MESSAGING & OFFERS ==========
CREATE TABLE conversation (
  id           UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  listing_id   UUID NOT NULL REFERENCES listing(id) ON DELETE CASCADE,
  seller_id    UUID NOT NULL REFERENCES app_user(id) ON DELETE CASCADE,
  buyer_id     UUID NOT NULL REFERENCES app_user(id) ON DELETE CASCADE,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (listing_id, seller_id, buyer_id)
);

CREATE TABLE message (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID NOT NULL REFERENCES conversation(id) ON DELETE CASCADE,
  sender_id       UUID NOT NULL REFERENCES app_user(id) ON DELETE CASCADE,
  body            TEXT NOT NULL CHECK (LENGTH(body) BETWEEN 1 AND 2000),
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  is_system       BOOLEAN NOT NULL DEFAULT FALSE,
  deleted_at      TIMESTAMPTZ
);
CREATE INDEX ON message (conversation_id, created_at);
CREATE INDEX ON message (created_at DESC);

CREATE TYPE offer_status AS ENUM ('pending','accepted','declined','retracted','expired');

CREATE TABLE offer (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID NOT NULL REFERENCES conversation(id) ON DELETE CASCADE,
  from_buyer      BOOLEAN NOT NULL,      -- TRUE if buyerâ†’seller, FALSE if counter-offer
  price_cents     INTEGER NOT NULL CHECK (price_cents > 0),
  currency        CHAR(3) NOT NULL DEFAULT 'USD' CHECK (currency IN ('USD', 'EUR', 'GBP', 'CAD', 'AUD', 'JPY', 'CHF', 'SEK', 'NOK', 'DKK')),
  status          offer_status NOT NULL DEFAULT 'pending',
  expires_at      TIMESTAMPTZ,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  version         INTEGER NOT NULL DEFAULT 1 -- Optimistic locking
);
CREATE INDEX ON offer (conversation_id, created_at);
CREATE INDEX ON offer (expires_at) WHERE expires_at IS NOT NULL;

-- ========== ORDERS (optional; if you support checkout) ==========
CREATE TYPE order_status AS ENUM ('created','paid','fulfilled','cancelled','refunded');

CREATE TABLE "order" (
  id            UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  listing_id    UUID NOT NULL REFERENCES listing(id),
  buyer_id      UUID NOT NULL REFERENCES app_user(id),
  seller_id     UUID NOT NULL REFERENCES app_user(id),
  qty           INTEGER NOT NULL DEFAULT 1 CHECK (qty > 0),
  amount_cents  INTEGER NOT NULL CHECK (amount_cents > 0),
  currency      CHAR(3) NOT NULL DEFAULT 'USD' CHECK (currency IN ('USD', 'EUR', 'GBP', 'CAD', 'AUD', 'JPY', 'CHF', 'SEK', 'NOK', 'DKK')),
  status        order_status NOT NULL DEFAULT 'created',
  shipping_addr JSONB,         -- if shipping supported
  created_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at    TIMESTAMPTZ NOT NULL DEFAULT now(),
  version       INTEGER NOT NULL DEFAULT 1 -- Optimistic locking
);
CREATE INDEX ON "order" (buyer_id, created_at);
CREATE INDEX ON "order" (seller_id, created_at);
CREATE INDEX ON "order" (status, created_at);

-- ========== REVIEWS ==========
CREATE TABLE review (
  id          UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  rater_id    UUID NOT NULL REFERENCES app_user(id) ON DELETE CASCADE,
  ratee_id    UUID NOT NULL REFERENCES app_user(id) ON DELETE CASCADE,
  order_id    UUID REFERENCES "order"(id) ON DELETE SET NULL,
  rating      SMALLINT NOT NULL CHECK (rating BETWEEN 1 AND 5),
  comment     TEXT CHECK (comment IS NULL OR LENGTH(comment) <= 1000),
  created_at  TIMESTAMPTZ NOT NULL DEFAULT now(),
  UNIQUE (rater_id, ratee_id, order_id)
);

-- ========== MODERATION & REPORTS ==========
CREATE TYPE report_target AS ENUM ('listing','user','message');
CREATE TYPE report_reason AS ENUM ('spam','fraud','counterfeit','abuse','other');

CREATE TABLE report (
  id           UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  reporter_id  UUID NOT NULL REFERENCES app_user(id) ON DELETE CASCADE,
  target_type  report_target NOT NULL,
  target_id    UUID NOT NULL,  -- FK enforced at app layer due to polymorphism
  reason       report_reason NOT NULL,
  details      TEXT,
  created_at   TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX ON report (target_type, target_id);

-- ========== NOTIFICATION SYSTEM ==========
CREATE TYPE notification_type AS ENUM ('message', 'offer', 'order', 'review', 'system');
CREATE TYPE notification_status AS ENUM ('unread', 'read', 'archived');

CREATE TABLE notification (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id         UUID NOT NULL REFERENCES app_user(id) ON DELETE CASCADE,
  type            notification_type NOT NULL,
  title           TEXT NOT NULL CHECK (LENGTH(title) BETWEEN 1 AND 200),
  body            TEXT CHECK (body IS NULL OR LENGTH(body) <= 1000),
  data            JSONB, -- Additional data for the notification
  status          notification_status NOT NULL DEFAULT 'unread',
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now(),
  read_at         TIMESTAMPTZ
);
CREATE INDEX ON notification (user_id, status, created_at DESC);
CREATE INDEX ON notification (created_at DESC);

-- ========== AUDIT TRAIL ==========
CREATE TYPE audit_action AS ENUM ('create', 'update', 'delete', 'login', 'logout', 'password_change');

CREATE TABLE audit_log (
  id              UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id         UUID REFERENCES app_user(id) ON DELETE SET NULL,
  action          audit_action NOT NULL,
  table_name      TEXT NOT NULL,
  record_id       UUID,
  old_values      JSONB,
  new_values      JSONB,
  ip_address      INET,
  user_agent      TEXT,
  created_at      TIMESTAMPTZ NOT NULL DEFAULT now()
);
CREATE INDEX ON audit_log (user_id, created_at DESC);
CREATE INDEX ON audit_log (table_name, record_id, created_at DESC);
CREATE INDEX ON audit_log (created_at DESC);

-- ========== SMALL UTILITIES ==========
-- Auto-update updated_at
CREATE OR REPLACE FUNCTION set_updated_at() RETURNS trigger AS $$
BEGIN NEW.updated_at = now(); RETURN NEW; END; $$ LANGUAGE plpgsql;
CREATE TRIGGER listing_set_updated_at BEFORE UPDATE ON listing
FOR EACH ROW EXECUTE FUNCTION set_updated_at();
CREATE TRIGGER order_set_updated_at BEFORE UPDATE ON "order"
FOR EACH ROW EXECUTE FUNCTION set_updated_at();

-- Increment version for optimistic locking
CREATE OR REPLACE FUNCTION increment_version() RETURNS trigger AS $$
BEGIN NEW.version = OLD.version + 1; RETURN NEW; END; $$ LANGUAGE plpgsql;
CREATE TRIGGER listing_increment_version BEFORE UPDATE ON listing
FOR EACH ROW EXECUTE FUNCTION increment_version();
CREATE TRIGGER offer_increment_version BEFORE UPDATE ON offer
FOR EACH ROW EXECUTE FUNCTION increment_version();
CREATE TRIGGER order_increment_version BEFORE UPDATE ON "order"
FOR EACH ROW EXECUTE FUNCTION increment_version();

-- Validate order quantity against listing availability
CREATE OR REPLACE FUNCTION validate_order_qty() RETURNS trigger AS $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM listing 
    WHERE id = NEW.listing_id 
    AND qty_available >= NEW.qty 
    AND status = 'active'
  ) THEN
    RAISE EXCEPTION 'Order quantity exceeds available quantity or listing is not active';
  END IF;
  RETURN NEW;
END; $$ LANGUAGE plpgsql;
CREATE TRIGGER validate_order_qty_trigger BEFORE INSERT ON "order"
FOR EACH ROW EXECUTE FUNCTION validate_order_qty();

-- Soft delete function
CREATE OR REPLACE FUNCTION soft_delete() RETURNS trigger AS $$
BEGIN
  NEW.deleted_at = now();
  RETURN NEW;
END; $$ LANGUAGE plpgsql;

-- Additional business logic constraints
-- Prevent users from rating themselves
ALTER TABLE review ADD CONSTRAINT check_no_self_rating 
  CHECK (rater_id != ratee_id);

-- Prevent users from creating conversations with themselves
ALTER TABLE conversation ADD CONSTRAINT check_no_self_conversation 
  CHECK (seller_id != buyer_id);

-- Ensure price consistency between offers and orders
CREATE OR REPLACE FUNCTION validate_offer_price() RETURNS trigger AS $$
BEGIN
  -- Check if offer price is reasonable (not more than 10x listing price)
  IF EXISTS (
    SELECT 1 FROM conversation c
    JOIN listing l ON c.listing_id = l.id
    WHERE c.id = NEW.conversation_id
    AND NEW.price_cents > l.price_cents * 10
  ) THEN
    RAISE EXCEPTION 'Offer price is unreasonably high compared to listing price';
  END IF;
  RETURN NEW;
END; $$ LANGUAGE plpgsql;
CREATE TRIGGER validate_offer_price_trigger BEFORE INSERT ON offer
FOR EACH ROW EXECUTE FUNCTION validate_offer_price();

-- Prevent duplicate active offers in same conversation
CREATE UNIQUE INDEX idx_unique_active_offer ON offer (conversation_id) 
WHERE status = 'pending';

-- Add email index for faster lookups
CREATE INDEX idx_app_user_email ON app_user (email);

-- Add location index for geographic queries
CREATE INDEX idx_location_area_geo ON location_area (country_code, admin1, city, postal_code);

